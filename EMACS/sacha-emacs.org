#+TITLE: Sacha Chua's Emacs configuration
#+OPTIONS: toc:4 h:4

* Configuration
Inspired by the [[http://eschulte.me/emacs24-starter-kit/#installation][Emacs Starter Kit]], I set up my configuration file
using Org-babel. Because my username is Sacha, I can save this as
Sacha.org in my =~/.emacs.d= directory to have it automatically load.
You could load it with =(org-babel-load-file "/path/to/file")=,
changing the path appropriately, but you'll probably want to tweak it
extensively first. 

This page: [[http://dl.dropbox.com/u/3968124/sacha-emacs.html][HTML]] - [[http://dl.dropbox.com/u/3968124/sacha-emacs.org][Org]] - [[https://dl.dropbox.com/u/3968124/sacha-emacs.el][.el]]

** Personal information

#+begin_src emacs-lisp
  (setq user-full-name "Sacha Chua"
        user-mail-address "sacha@sachachua.com")
#+end_src

** Emacs initialization
*** Add my elisp directory and other files

#+begin_src emacs-lisp
(add-to-list 'load-path "~/elisp")
(add-to-list 'load-path "~/elisp/org2blog")
(add-to-list 'load-path "~/elisp/use-package")
(require 'use-package)
(require 'bind-key)
(add-to-list 'load-path "~/elisp/artbollocks-mode")
(load-file "~/.emacs.secrets")
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
(starter-kit-load "org")
#+end_src
*** Byte-compile my init files to speed things up next time

#+begin_src emacs-lisp
(defun sacha/byte-recompile ()
  (interactive)
  (byte-recompile-directory "~/.emacs.d" 0)
  (byte-recompile-directory "~/elisp" 0))
#+end_src

*** Load other parts of the Emacs Starter Kit

#+begin_src emacs-lisp
  (starter-kit-load "misc-recommended")
  (require 'cl)
#+end_src

For some reason, show-paren-mode misbehaves in my copy of emacs-starter-kit.
#+begin_src emacs-lisp
(show-paren-mode -1)
#+end_src

I don't want spell-checking to run automatically. It's a little distracting.

#+begin_src emacs-lisp
(remove-hook 'text-mode-hook 'turn-on-flyspell)
#+end_src

*** Install packages if necessary

ELPA makes it easy to install packages without tracking down all the
different websites. Let's define a function that makes it easy to
install packages.

#+begin_src emacs-lisp
(defun sacha/package-install (package &optional repository)
  "Install PACKAGE if it has not yet been installed.
If REPOSITORY is specified, use that."
  (unless (package-installed-p package)
    (let ((package-archives (if repository
                                (list (assoc repository package-archives))
                              package-archives)))
    (package-install package))))
#+end_src

*** Share my Emacs configuration

This code gets around the fact that my config is called Sacha.org, but
I want it to export as sacha-emacs.org in my Dropbox's public
directory.

#+begin_src emacs-lisp
  (defun sacha/org-share-emacs ()
    "Share my Emacs configuration."
    (interactive)
    (let* ((destination-dir "~/Dropbox/Public/")
           (destination-filename "sacha-emacs.org"))
      (save-restriction
        (save-excursion
          (widen)
          (write-region (point-min) (point-max) (expand-file-name destination-filename destination-dir))
          (with-current-buffer (find-file-noselect (expand-file-name
                                                    destination-filename destination-dir))
            (org-babel-tangle-file buffer-file-name 
                                   (expand-file-name
                                    "sacha-emacs.el" destination-dir) "emacs-lisp")
            (org-export-as-html nil)
            )))))
    #+end_src

** General configuration
*** Ace Jump mode  :drill:
    :PROPERTIES:
    :ID:       56f173e7-d2a2-4589-84d7-c6b435c8a5f8
    :DRILL_LAST_INTERVAL: 0.0
    :DRILL_REPEATS_SINCE_FAIL: 1
    :DRILL_TOTAL_REPEATS: 3
    :DRILL_FAILURE_COUNT: 2
    :DRILL_AVERAGE_QUALITY: 1.667
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 0
    :DRILL_LAST_REVIEWED: [2013-03-13 Wed 09:50]
    :END:

Quickly jump to a position in the current view.

#+begin_src emacs-lisp
  (use-package ace-jump-mode
    :bind ("C-c SPC" . ace-jump-mode))
#+end_src

*** Windows configuration :drill:
    SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       440c0b9a-9068-450b-89a3-a20c8ec1f447
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 1
    :DRILL_FAILURE_COUNT: 0
    :DRILL_AVERAGE_QUALITY: 3.0
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 23:14]
    :END:
#+begin_src emacs-lisp
  (use-package winner
    :config (winner-mode 1))
#+end_src
*** Editing multiple things
**** Multiple cursors mode                                            :drill:
     SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       o2b:61b0ffae-669b-4360-98fd-a6f0ea6f018e
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 2
    :DRILL_FAILURE_COUNT: 1
    :DRILL_AVERAGE_QUALITY: 2.5
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
    :END:

I often define keyboard macros to process multiple lines in a region.
Maybe =multiple-cursors= will be an even better way. Looks promising!
[[http://emacsrocks.com/e13.html][See Emacs Rocks episode 13 (multiple-cursors) for a great demo]].

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind 
     (("C->" . mc/mark-next-like-this)
      ("C-<" . mc/mark-previous-like-this)
      ("C-*" . mc/mark-all-like-this)))
#+end_src

Thanks to [[http://irreal.org/blog/?p=1733][Irreal]] and [[http://planet.emacsen.org/][Planet Emacsen]] for the link!

**** All  :drill:
     SCHEDULED: <2013-03-03 Sun>
     :PROPERTIES:
     :ID:       211c02ab-9a9c-4e81-bc95-ce8e48db67b1
     :DRILL_LAST_INTERVAL: 3.86
     :DRILL_REPEATS_SINCE_FAIL: 2
     :DRILL_TOTAL_REPEATS: 3
     :DRILL_FAILURE_COUNT: 2
     :DRILL_AVERAGE_QUALITY: 2.333
     :DRILL_EASE: 2.36
     :DRILL_LAST_QUALITY: 3
     :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
     :END:

M-x all lets you edit all lines matching a given regexp.

#+begin_src emacs-lisp
(use-package all)
#+end_src

*** Edit list   :drill:
    SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       e9147cb0-bad0-421c-9396-4f9045d6ebbb
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 3
    :DRILL_FAILURE_COUNT: 2
    :DRILL_AVERAGE_QUALITY: 2.333
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
    :END:

M-x edit-list makes it easier to edit an Emacs Lisp list.

#+begin_src emacs-lisp
(use-package edit-list
  :commands edit-list)
#+end_src

*** Little editing shortcuts

**** Navigation
In my world, sentences end with a single space. This makes
sentence navigation commands work for me.
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src
**** Helm

I'm trying to get the hang of using Helm for completing everything so
that I don't have to deal with different keybindings or approaches.
Setting =helm-input-idle-delay= to 0.1 (I want my results and I want
them now!) should cut down on the number of times I M-x and type in
the exact command name, hit RET, and then end up on the wrong command.

#+begin_src emacs-lisp
  (use-package helm
    :init
    (progn 
      (require 'helm-config) 
      (setq helm-input-idle-delay 0.1) ;; I want it now!
      (setq helm-candidate-number-limit 10)
      (helm-mode))
    :bind (("C-c h" . helm-mini)))
#+end_src

**** Windmove

Windmove doesn't behave well with Org, so we need to use different keybindings.

#+begin_src emacs-lisp
  (use-package windmove
    :bind
    (("<f2> <right>" . windmove-right)
     ("<f2> <left>" . windmove-left)
     ("<f2> <up>" . windmove-up)
     ("<f2> <down>" . windmove-down)))
#+end_src
**** When I press Enter
I almost always want to go to the right indentation on the next line.
#+begin_src emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+end_src

**** Searching based on the current word
This lets me search up and down.

#+begin_src emacs-lisp
  (defun sacha/search-word-backward ()
    "Find the previous occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-backward "w_")
      (goto-char
       (if (re-search-backward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))
  
  (defun sacha/search-word-forward ()
    "Find the next occurrence of the current word."
    (interactive)
    (let ((cur (point)))
      (skip-syntax-forward "w_")
      (goto-char
       (if (re-search-forward (concat "\\_<" (current-word) "\\_>") nil t)
           (match-beginning 0)
         cur))))
  (global-set-key '[M-up] 'sacha/search-word-backward)
  (global-set-key '[M-down] 'sacha/search-word-forward)
  (defadvice search-for-keyword (around sacha activate)
    "Match in a case-insensitive way."
    (let ((case-fold-search t))
      ad-do-it))
#+end_src

**** Tramp and editing files over SSH
Emacs lets you edit files on remote servers, which is pretty darn
cool.

#+begin_src emacs-lisp
(setq tramp-default-method "ssh")
#+end_src

**** Minibuffer editing
    Sometimes you want to be able to do fancy things with the text
    that you're entering into the minibuffer. This binds =C-M-e= in a
    minibuffer) so that you can edit the contents of the minibuffer
    before submitting it.

#+begin_src emacs-lisp
  (use-package miniedit
    :commands minibuffer-edit
    :init
    (progn
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-ns-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-completion-map)
      (bind-key "\M-\C-e" 'miniedit minibuffer-local-must-match-map)))
#+end_src

*** Change "yes or no" to "y or n"

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)   
#+end_src

*** Set up a white-on-black color scheme

I like white on black because I find it to be more restful. The
color-theme in ELPA is buggy, though, so we define some advice to make
it work. Some things still aren't quite right, though.

#+begin_src emacs-lisp
  (defadvice color-theme-alist (around sacha activate)
    (if (ad-get-arg 0)
        ad-do-it
      nil))
  (sacha/package-install 'color-theme)
  (defun sacha/setup-color-theme ()
    (interactive)
    (color-theme-hober)
    (set-face-foreground 'secondary-selection "darkblue")
    (set-face-background 'secondary-selection "lightblue")
    (set-face-background 'font-lock-doc-face "black")
    (set-face-foreground 'font-lock-doc-face "wheat")
    (set-face-background 'font-lock-string-face "black"))
  (use-package color-theme
    :init
    (sacha/setup-color-theme))
#+end_src

*** Frequently-accessed files
Registers allow you to jump to a file or other location quickly. To
jump to a register, use =C-x r j= followed by the letter of the
register.

#+begin_src emacs-lisp :results silent
  (dolist
      (r `((?i (file . ,(expand-file-name (concat user-login-name ".org") starter-kit-dir)))
           (?o (file . "~/personal/organizer.org"))
           (?b (file . "~/personal/business.org"))
           ))
    (set-register (car r) (cadr r)))
#+end_src

*** Kill-ring management  :drill:
    SCHEDULED: <2013-03-03 Sun>
    :PROPERTIES:
    :ID:       508ef5ff-f338-4cd6-8201-9bc76fa432e8
    :DRILL_LAST_INTERVAL: 3.86
    :DRILL_REPEATS_SINCE_FAIL: 2
    :DRILL_TOTAL_REPEATS: 2
    :DRILL_FAILURE_COUNT: 1
    :DRILL_AVERAGE_QUALITY: 2.5
    :DRILL_EASE: 2.36
    :DRILL_LAST_QUALITY: 3
    :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
    :END:

Make sense of the kill ring

#+begin_src emacs-lisp
  (sacha/package-install 'browse-kill-ring)
  (use-package browse-kill-ring
    :init 
    (progn 
      (browse-kill-ring-default-keybindings) ;; M-y
      (setq browse-kill-ring-quit-action 'save-and-restore)))      
#+end_src

*** Key chords 
I'm on a Dvorak keyboard, so these might not work for you.
Experimenting with this!
#+begin_src emacs-lisp
  (use-package key-chord
    :init
    (progn 
      (key-chord-mode 1)
      (key-chord-define-global "cg"     'undo)
      (key-chord-define-global "yp"     'other-window)))
#+end_src
*** Quantified Emacs!

#+begin_src emacs-lisp
  (use-package keyfreq
    :init
    (progn
      (keyfreq-mode 1)
      (keyfreq-autosave-mode 1)))
#+end_src
*** Better undo
#+begin_src emacs-lisp
  (use-package undo-tree
    :init (global-undo-tree-mode))
#+end_src
*** Fix ido in Emacs Starter Kit

For some reason, some things don't have modified times on Microsoft
Windows.

#+begin_src emacs-lisp
(defun ido-sort-mtime ()
  (setq ido-temp-list
        (sort ido-temp-list 
              (lambda (a b)
                (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                      (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                  (if (= (or (nth 0 ta) 0) (or (nth 0 tb) 0))
                      (> (or (nth 1 ta) 0) (or (nth 1 tb)))
                    (> (or (nth 0 ta) 0) (or (nth 0 tb) 0)))))))
  (ido-to-end  ;; move . files to end (again)
   (delq nil (mapcar
              (lambda (x) (if (string-equal (substring x 0 1) ".") x))
              ido-temp-list))))
#+end_src

*** Tramp on Windows
#+begin_src emacs-lisp
(setq tramp-default-method "plink")
(setq tramp-auto-save-directory "c:\\sacha\\tmp")
(getenv "PATH")
#+end_src

** Writing
*** Avoiding weasel words
    #+begin_src emacs-lisp
      (use-package artbollocks-mode
        :init
        (progn
          (setq artbollocks-weasel-words-regex
                (concat "\\b" (regexp-opt
                               '("one of the"
                                 "should"
                                 "just"
                                 "sort of"
                                 "a lot"
                                 "probably"
                                 "maybe"
                                 "perhaps"
                                 "I think"
                                 "really"
                                 "pretty"
                                 "maybe"
                                 "nice"
                                 "action"
                                 "utilize"
                                 "leverage") t) "\\b"))
          ;; Don't show the art critic words, or at least until I figure
          ;; out my own jargon
          (setq artbollocks-jargon nil)))
#+end_src

*** Unfill paragraph
From https://raw.github.com/qdot/conf_emacs/master/emacs_conf.org
#+begin_src emacs-lisp
    (defun unfill-paragraph ()
      "Takes a multi-line paragraph and makes it into a single line of text."
      (interactive)
      (let ((fill-column (point-max)))
        (fill-paragraph nil)))
#+end_src

*** Dictionary
#+begin_src emacs-lisp
(add-to-list 'load-path "~/elisp/dictionary-el")
(load-library "dictionary-init")
#+end_src
** Org

I use [[http://www.orgmode.org][Org Mode]] to take notes, publish my blog, and do all sorts of
stuff.

*** Modules
Org has a whole bunch of optional modules. These are the ones I'm
currently experimenting with.
#+begin_src emacs-lisp
  (setq org-modules '(org-bbdb 
                      org-contacts
                      org-gnus
                      org-drill
                      org-info
                      org-jsinfo
                      org-habit
                      org-irc
                      org-mouse
                      org-annotate-file
                      org-eval
                      org-expiry
                      org-interactive-query
                      org-man
                      org-panel
                      org-screen
                      org-toc))
#+end_src

*** Keyboard shortcuts

    #+begin_src emacs-lisp
      (bind-key "C-c r" 'org-capture)
      (bind-key "C-c a" 'org-agenda)
      (bind-key "C-c l" 'org-store-link)
      (bind-key "C-c L" 'org-insert-link-global)
      (bind-key "C-c O" 'org-open-at-point-global)
      (bind-key "<f9> <f9>" 'org-agenda-list)
      (bind-key "<f9> <f8>" (lambda () (interactive) (org-capture nil "r")))
      (eval-after-load 'org
        '(progn
           (bind-key "C-TAB" 'org-cycle org-mode-map)
           (bind-key "C-c v" 'org-show-todo-tree org-mode-map)
           (bind-key "C-c C-r" 'org-refile org-mode-map)
           (bind-key "C-c R" 'org-reveal org-mode-map)))
#+end_src

=append-next-kill= is more useful to me than =org-table-copy-region=.

#+begin_src emacs-lisp
  (eval-after-load 'org
    '(progn
       (bind-key "C-M-w" 'append-next-kill org-mode-map)))
#+end_src

I don't use the diary, but I do use the clock a lot.

#+begin_src emacs-lisp
  (use-package org-agenda
    :init (bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
#+end_src
    
*** Taking notes

    My org files are in my =personal= directory, which is actually a
    symlink to a directory in my Dropbox. That way, I can update my
    Org files from multiple computers.
    
#+begin_src emacs-lisp
  (setq org-directory "~/personal")
  (setq org-default-notes-file "~/personal/organizer.org")
#+end_src

**** Templates

     I use =org-capture= templates to quickly jot down tasks, ledger
     entries, notes, and other semi-structured pieces of information.
#+begin_src emacs-lisp     
       (setq org-capture-templates
        '(("t" "Tasks" entry 
           (file+headline "~/personal/organizer.org" "Tasks")
           "* TODO %^{Task}    %^g
  SCHEDULED: %^t
  %?
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :END:")
          ("b" "Business task" entry
           (file+headline "~/personal/business.org" "Tasks")
           "* TODO %^{Task}
  SCHEDULED: %^t
  %?
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :END:")
          ("p" "People task" entry
           (file+headline "~/personal/people.org" "Tasks")
           "* TODO %^{Task}
  SCHEDULED: %^t
  %?
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :END:")
          ("d" "Done task" entry
           (file+headline "~/personal/organizer.org" "Tasks")
           "* DONE %^{Task}
  SCHEDULED: %^t
  %?")
          ("q" "Quick task" entry
           (file+headline "~/personal/organizer.org" "Tasks")
           "* TODO %^{Task}
  SCHEDULED: %^t
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
  :END:"
           :immediate-finish t)
          ("l" "Ledger entries")
          ("lm" "MBNA" plain
           (file "~/personal/ledger")
           "%(org-read-date) %^{Payee}
    Liabilities:MBNA  
    Expenses:%^{Account}  $%^{Amount}
  " :immediate-finish)
          ("ln" "No Frills" plain
           (file "~/personal/ledger")
           "%(let ((org-read-date-prefer-future nil)) (org-read-date)) * No Frills
    Liabilities:MBNA  
    Assets:Wayne:Groceries  $%^{Amount}
  " :immediate-finish)    
          ("lc" "Cash" plain
           (file "~/personal/ledger")
           "%(org-read-date) * %^{Payee}
    Expenses:Cash 
    Expenses:%^{Account}  %^{Amount}
  ")             
          ("b" "Book" entry
           (file+datetree "~/personal/books.org" "Inbox")
           "* %^{Title}  %^g
  %i
  ,*Author(s):* %^{Author} \\\\
  ,*ISBN:* %^{ISBN}
  
  %?
  
  ,*Review on:* %^t \\
  %a
  %U"
           :clock-in :clock-resume)
           ("c" "Contact" entry (file "~/personal/contacts.org")
            "* %(org-contacts-template-name)
  :PROPERTIES:
  :EMAIL: %(org-contacts-template-email)
  :END:")
           ("r" "Notes" entry
            (file+datetree "~/personal/organizer.org" "Inbox")
            "* %?\n\n%i\n"
            :clock-in :clock-resume)))
  (global-set-key (kbd "C-M-r") 'org-capture)
#+end_src
**** Refiling

    #+begin_src emacs-lisp
        (setq org-reverse-note-order t)
        (setq org-refile-use-outline-path nil)
        (setq org-refile-allow-creating-parent-nodes 'confirm)
        (setq org-refile-targets
              '(("~/personal/contacts.org" . (:maxlevel . 2))
                ("~/personal/decisions.org" . (:maxlevel . 3))
                ("~/personal/business.org" . (:maxlevel . 4))
                ("~/personal/organizer.org" . (:maxlevel . 4))
                ("~/personal/outline.org" . (:maxlevel . 3))))
        (setq org-blank-before-new-entry nil)
        (defun my/verify-refile-target ()
          "Exclude todo keywords with a DONE state from refile targets"
          (or (not (member (nth 2 (org-heading-components)) org-done-keywords)))
              (save-excursion (org-goto-first-child)))
        (setq org-refile-target-verify-function 'my/verify-refile-target)
    #+end_src
    
**** Estimating WPM

     I'm curious about how fast I type some things.
#+begin_src emacs-lisp
(require 'org-clock)
(defun sacha/org-entry-wpm ()
  (interactive)
  (save-restriction
    (save-excursion
      (org-narrow-to-subtree)
      (goto-char (point-min))
      (let* ((words (count-words-region (point-min) (point-max)))
	     (minutes (org-clock-sum-current-item))
	     (wpm (/ words minutes)))
	(message "WPM: %d (words: %d, minutes: %d)" wpm words minutes)
	(kill-new (number-to-string wpm))))))
#+end_src

*** Managing tasks
**** Track TODO state
     #+begin_src emacs-lisp
       (setq org-todo-keywords
        '((sequence
           "TODO(t)"  ; next action
           "TOBLOG(b)"  ; next action
           "STARTED(s)"
           "WAITING(w@/!)"
           "POSTPONED(p)" "SOMEDAY(s@/!)" "|" "DONE(x!)" "CANCELLED(c@)")
          (sequence "TODELEGATE(-)" "DELEGATED(d)" "COMPLETE(x)")))
#+end_src
     
**** Strike through DONE headlines

I wanted a quick way to visually distinguish DONE tasks from tasks I
still need to do. This [[http://lists.gnu.org/archive/html/emacs-orgmode/2007-03/msg00179.html][handy snippet from the Emacs Org-mode mailing list]] does the trick by striking through the headlines for DONE tasks.

#+begin_src emacs-lisp
(setq org-fontify-done-headline t)
(custom-set-faces
 '(org-done ((t (:foreground "PaleGreen"   
                 :weight normal
                 :strike-through t))))
 '(org-headline-done 
            ((((class color) (min-colors 16) (background dark)) 
               (:foreground "LightSalmon" :strike-through t)))))
#+end_src

**** Projects
     #+begin_src emacs-lisp
       (setq org-tags-exclude-from-inheritance '("PROJECT"))
     #+end_src
**** Tag tasks
     #+begin_src emacs-lisp
       (setq org-tag-alist '(("@work" . ?b) 
                             ("@home" . ?h) 
                             ("@writing" . ?w)
                             ("@errands" . ?e) 
                             ("@drawing" . ?d)
                             ("@coding" . ?c)
                             ("@phone" . ?p)
                             ("@reading" . ?r)
                             ("@computer" . ?l)
                             ("quantified" . ?q)))
     #+end_src
**** Enable filtering by effort estimates

#+begin_src emacs-lisp
  (setq org-global-properties
        '(("Effort_ALL". "0:05 0:15 0:30 1:00 2:00 3:00 4:00")))
#+end_src
     
**** Track time

     #+begin_src emacs-lisp
     (setq org-clock-idle-time nil)
     (setq org-log-done 'time)
     (defadvice org-clock-in (after wicked activate)
  "Mark STARTED when clocked in"
  (save-excursion
    (catch 'exit
      (org-back-to-heading t)
      (if (looking-at org-outline-regexp) (goto-char (1- (match-end 0))))
      (if (looking-at (concat " +" org-todo-regexp "\\( +\\|[ \t]*$\\)"))
	  (org-todo "STARTED")))))
#+end_src
(setq org-clock-idle-time nil)
     
**** Habits

     I like using org-habits to track consistency. My task names tend
     to be a bit long, though, so I've configured the graph column to
     show a little bit more to the right.
     
     #+begin_src emacs-lisp
     (setq org-habit-graph-column 80)
#+end_src
*** Estimating tasks
From "Add an effort estimate on the fly when clocking in" on the
[[http://orgmode.org/worg/org-hacks.html][Org Hacks]] page:

#+begin_src emacs-lisp
(add-hook 'org-clock-in-prepare-hook
          'my-org-mode-ask-effort)

(defun my-org-mode-ask-effort ()
  "Ask for an effort estimate when clocking in."
  (unless (org-entry-get (point) "Effort")
    (let ((effort
           (completing-read
            "Effort: "
            (org-entry-get-multivalued-property (point) "Effort"))))
      (unless (equal effort "")
        (org-set-property "Effort" effort)))))
#+end_src

# <<subset>>
*** Modifying org agenda so that I can display a subset of tasks

I want to create an agenda command that displays a list of tasks by
context. That way, I can quickly preview a bunch of contexts and
decide what I feel like doing the most.

#+begin_src emacs-lisp
  (defvar sacha/org-agenda-limit-items nil "Number of items to show in agenda to-do views; nil if unlimited.")
  (defadvice org-agenda-finalize-entries (around sacha activate)
    (if sacha/org-agenda-limit-items
        (progn
          (setq list (mapcar 'org-agenda-highlight-todo list))
          (if nosort
            (setq ad-return-value
              (subseq list 0 sacha/org-agenda-limit-items))
            (when org-agenda-before-sorting-filter-function
              (setq list (delq nil (mapcar org-agenda-before-sorting-filter-function list))))
            (setq ad-return-value
                  (mapconcat 'identity
                             (delq nil 
                                   (subseq
                                    (sort list 'org-entries-lessp)
                                    0
                                    sacha/org-agenda-limit-items))
                             "\n"))))
      ad-do-it))
#+end_src

*** Fixing relative dates

If today is Friday, I want +fri to be _next_ Friday.

#+begin_src emacs-lisp
(defadvice org-read-date-get-relative (after sacha activate)
  (if (equal ad-return-value '(0 "d" nil))
      (setq ad-return-value '(7 "d" nil))))
#+end_src

*** Flexible scheduling of tasks

I want to be able to schedule tasks for dates like the first Saturday
of every month. Fortunately, [[http://stackoverflow.com/questions/13555385/org-mode-how-to-schedule-repeating-tasks-for-the-first-saturday-of-every-month][someone else has figured that out!]]

#+begin_src emacs-lisp
;; Get this from https://raw.github.com/chenfengyuan/elisp/master/next-spec-day.el
(load-file "~/elisp/next-spec-day.el")
#+end_src
*** Org agenda
**** Basic configuration
I have quite a few Org files, but I keep my agenda items and TODOs in
only a few of them them for faster scanning.

#+begin_src emacs-lisp
    (setq org-agenda-files '("~/personal/organizer.org"
                             "~/personal/people.org"
                             "~/personal/business.org"
                             "~/personal/routines.org"))
#+end_src

I like looking at two days at a time when I plan using the Org
agenda. I want to see my log entries, but I don't want to see
scheduled items that I've finished. I like seeing a time grid so that
I can get a sense of how appointments are spread out.

#+begin_src emacs-lisp
  (setq org-agenda-span 2)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-time-grid
        '((daily today require-timed)
         "----------------"
         (800 1000 1200 1400 1600 1800)))
  (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
#+end_src

Some other keyboard shortcuts:

#+begin_src emacs-lisp
(define-key org-agenda-mode-map "Y" 'org-agenda-todo-yesterday)
#+end_src

# <<project_subtasks>>
**** Display projects with associated subtasks

I wanted a view that showed projects with a few subtasks underneath
them. Here's a sample of the output:

#+begin_example
Headlines with TAGS match: +PROJECT
Press `C-u r' to search again with new search string
  organizer:  Set up communication processes for Awesome Foundation Toronto
  organizer:  TODO Announce the next pitch night
  organizer:  TODO Follow up with the winner of the previous pitch night for any news to include in the updates

  organizer:  Tidy up the house so that I can find things quickly
  organizer:  TODO Inventory all the things in closets and boxes         :@home:
  organizer:  TODO Drop things off for donation                       :@errands:

  organizer:  Learn how to develop for Android devices
#+end_example

#+begin_src emacs-lisp  
  (defun sacha/org-agenda-project-agenda ()
    "Return the project headline and up to `sacha/org-agenda-limit-items' tasks."
    (save-excursion
      (let* ((marker (org-agenda-new-marker))
             (heading
              (org-agenda-format-item "" (org-get-heading) (org-get-category) nil))
             (org-agenda-restrict t)
             (org-agenda-restrict-begin (point))
             (org-agenda-restrict-end (org-end-of-subtree 'invisible))
             ;; Find the TODO items in this subtree
             (list (org-agenda-get-day-entries (buffer-file-name) (calendar-current-date) :todo)))
        (org-add-props heading
            (list 'face 'defaults
                  'done-face 'org-agenda-done
                  'undone-face 'default
                  'mouse-face 'highlight
                  'org-not-done-regexp org-not-done-regexp
                  'org-todo-regexp org-todo-regexp
                  'org-complex-heading-regexp org-complex-heading-regexp
                  'help-echo
                  (format "mouse-2 or RET jump to org file %s"
                          (abbreviate-file-name
                           (or (buffer-file-name (buffer-base-buffer))
                               (buffer-name (buffer-base-buffer))))))
          'org-marker marker
          'org-hd-marker marker
          'org-category (org-get-category)
          'type "tagsmatch")
        (concat heading "\n"
                (org-agenda-finalize-entries list)))))
          
    (defun sacha/org-agenda-projects-and-tasks (match)
      "Show TODOs for all `org-agenda-files' headlines matching MATCH."
      (interactive "MString: ")
      (let ((todo-only nil))
        (if org-agenda-overriding-arguments
            (setq todo-only (car org-agenda-overriding-arguments)
                  match (nth 1 org-agenda-overriding-arguments)))
        (let* ((org-tags-match-list-sublevels
                org-tags-match-list-sublevels)
               (completion-ignore-case t)
               rtn rtnall files file pos matcher
               buffer)
          (when (and (stringp match) (not (string-match "\\S-" match)))
            (setq match nil))
          (setq matcher (org-make-tags-matcher match)
                match (car matcher) matcher (cdr matcher))
          (catch 'exit
            (if org-agenda-sticky
                (setq org-agenda-buffer-name
                      (if (stringp match)
                          (format "*Org Agenda(%s:%s)*"
                                  (or org-keys (or (and todo-only "M") "m")) match)
                        (format "*Org Agenda(%s)*" (or (and todo-only "M") "m")))))
            (org-agenda-prepare (concat "TAGS " match))
            (org-compile-prefix-format 'tags)
            (org-set-sorting-strategy 'tags)
            (setq org-agenda-query-string match)
            (setq org-agenda-redo-command
                  (list 'org-tags-view `(quote ,todo-only)
                        (list 'if 'current-prefix-arg nil `(quote ,org-agenda-query-string))))
            (setq files (org-agenda-files nil 'ifmode)
                  rtnall nil)
            (while (setq file (pop files))
              (catch 'nextfile
                (org-check-agenda-file file)
                (setq buffer (if (file-exists-p file)
                                 (org-get-agenda-file-buffer file)
                               (error "No such file %s" file)))
                (if (not buffer)
                    ;; If file does not exist, error message to agenda
                    (setq rtn (list
                               (format "ORG-AGENDA-ERROR: No such org-file %s" file))
                          rtnall (append rtnall rtn))
                  (with-current-buffer buffer
                    (unless (derived-mode-p 'org-mode)
                      (error "Agenda file %s is not in `org-mode'" file))
                    (save-excursion
                      (save-restriction
                        (if org-agenda-restrict
                            (narrow-to-region org-agenda-restrict-begin
                                              org-agenda-restrict-end)
                          (widen))
                        (setq rtn (org-scan-tags 'sacha/org-agenda-project-agenda matcher todo-only))
                        (setq rtnall (append rtnall rtn))))))))
            (if org-agenda-overriding-header
                (insert (org-add-props (copy-sequence org-agenda-overriding-header)
                            nil 'face 'org-agenda-structure) "\n")
              (insert "Headlines with TAGS match: ")
              (add-text-properties (point-min) (1- (point))
                                   (list 'face 'org-agenda-structure
                                         'short-heading
                                         (concat "Match: " match)))
              (setq pos (point))
              (insert match "\n")
              (add-text-properties pos (1- (point)) (list 'face 'org-warning))
              (setq pos (point))
              (unless org-agenda-multi
                (insert "Press `C-u r' to search again with new search string\n"))
              (add-text-properties pos (1- (point)) (list 'face 'org-agenda-structure)))
            (org-agenda-mark-header-line (point-min))
            (when rtnall
              (insert (mapconcat 'identity rtnall "\n") ""))
            (goto-char (point-min))
            (or org-agenda-multi (org-agenda-fit-window-to-buffer))
            (add-text-properties (point-min) (point-max)
                                 `(org-agenda-type tags
                                                   org-last-args (,todo-only ,match)
                                                   org-redo-cmd ,org-agenda-redo-command
                                                   org-series-cmd ,org-cmd))
            (org-agenda-finalize)
            (setq buffer-read-only t)))))
#+end_src

# <<agenda_commands>>
**** Org agenda custom commands

There are quite a few custom commands here, and I often forget to use
them. =) But it's good to define them, and over time, I'll get the
hang of using these more!

| Key         | Description                                                                                    |
| w           | What am I waiting for?                                                                         |
| T           | Not really an agenda command - shows the to-do tree in the current file                        |
| b           | Shows business-related tasks                                                                   |
| o           | Shows personal tasks and miscellaneous tasks (o: organizer)                                    |
| t           | Show all my to-dos                                                                             |
| w           | Show all tasks for the upcoming week                                                           |
| g ...       | Show tasks by context: b - business; c - coding; w - writing; p - phone; d - drawing, h - home |
| 0           | Show common contexts with up to 3 tasks each, so that I can choose what I feel like working on |
| ) (shift-0) | Show common contexts with all the tasks associated with them                                   |
| 9           | Show common contexts with up to 3 unscheduled tasks each                                       |
| ( (shift-9) | Show common contexts with all the unscheduled tasks associated with them                       |
| d           | Timeline for today (agenda, clock summary)                                                     |
| u           | Unscheduled tasks to do if I have free time                                                    |
| P           | Tasks by priority                                                                              |
| p           | My projects                                                                                    |
| 2           | Projects with tasks                                                                            |

#+begin_src emacs-lisp
  (defvar sacha/org-agenda-contexts
    '((tags-todo "+@phone/!-SOMEDAY")
      (tags-todo "+@work/!-SOMEDAY")
      (tags-todo "+@drawing/!-SOMEDAY")
      (tags-todo "+@coding/!-SOMEDAY")
      (tags-todo "+@writing/!-SOMEDAY")
      (tags-todo "+@computer/!-SOMEDAY")
      (tags-todo "+@home/!-SOMEDAY")
      (tags-todo "+@errands/!-SOMEDAY"))
    "Usual list of contexts.")
  (defun sacha/org-agenda-skip-scheduled ()
    (org-agenda-skip-entry-if 'scheduled 'deadline
                              'regexp "\n]+>"))
  (defun sacha/org-agenda-with-tip (arg)
    (org-agenda-list arg)
    (let ((inhibit-read-only t))
      (insert (sacha/random-keybinding) "\n")))
  (setq org-agenda-custom-commands
        `(("a" "Agenda" sacha/org-agenda-with-tip)
          ("T" todo-tree "TODO")
          ("b" todo ""
           ((org-agenda-files '("~/personal/business.org"))))
          ("o" todo ""
           ((org-agenda-files '("~/personal/organizer.org"))))
          ("t" todo ""
           ((org-agenda-prefix-format "")
            (org-agenda-cmp-user-defined 'sacha/org-sort-agenda-items-todo)
            (org-agenda-view-columns-initially t)
            ))
          ;; Weekly review
          ("w" "Weekly review" agenda "" ((org-agenda-span 7) (org-agenda-log-mode 1)))
          ("g" . "GTD Contexts")
          ("gb" "Business" todo ""  
           ((org-agenda-files '("~/personal/business.org"))
            (org-agenda-view-columns-initially t)))
          ("gc" "Coding" tags-todo "@coding" 
           ((org-agenda-view-columns-initially t)))
          ("gw" "Writing" tags-todo "@writing"
           ((org-agenda-view-columns-initially t)))
          ("gp" "Phone" tags-todo "@phone"
           ((org-agenda-view-columns-initially t)))
          ("gd" "Drawing" tags-todo "@drawing"
           ((org-agenda-view-columns-initially t)))
          ("gh" "Home" tags-todo "@home"
           ((org-agenda-view-columns-initially t)))
          ("ge" "Errands" tags-todo "@errands"
           ((org-agenda-view-columns-initially t)))
          ("0" "Top 3 by context"
           ,sacha/org-agenda-contexts
           ((org-agenda-sorting-strategy '(priority-up effort-down))
            (sacha/org-agenda-limit-items 3)))
          (")" "All by context"
           ,sacha/org-agenda-contexts
           ((org-agenda-sorting-strategy '(priority-down effort-down))
            (sacha/org-agenda-limit-items nil)))
          ("9" "Unscheduled top 3 by context"
           ,sacha/org-agenda-contexts
           ((org-agenda-skip-function 'sacha/org-agenda-skip-scheduled)
            (org-agenda-sorting-strategy '(priority-down effort-down))
            (sacha/org-agenda-limit-items 3)))
          ("(" "All unscheduled by context"
           ,sacha/org-agenda-contexts
           ((org-agenda-skip-function 'sacha/org-agenda-skip-scheduled)
            (org-agenda-sorting-strategy '(priority-down effort-down))
            ))
          ("d" "Timeline for today" ((agenda "" ))
           ((org-agenda-ndays 1)
            (org-agenda-show-log t)
            (org-agenda-log-mode-items '(clock closed))
            (org-agenda-clockreport-mode t)
            (org-agenda-entry-types '())))
          ("w" "Waiting for" todo "WAITING")
          ("u" "Unscheduled tasks" alltodo ""
           ((org-agenda-skip-function 'sacha/org-agenda-skip-scheduled)
            (org-agenda-overriding-header "Unscheduled TODO entries: ")))
          ("P" "By priority"
           ((tags-todo "+PRIORITY=\"A\"")
            (tags-todo "+PRIORITY=\"B\"")
            (tags-todo "+PRIORITY=\"\"")
            (tags-todo "+PRIORITY=\"C\""))
           ((org-agenda-prefix-format "%-10c %-10T %e ")
            (org-agenda-sorting-strategy '(tag-up category-keep effort-down))))
          ("p" tags "+PROJECT")
          ("2" "List projects with tasks" sacha/org-agenda-projects-and-tasks
           "+PROJECT"
             ((sacha/org-agenda-limit-items 3)))))
#+end_src
**** Make it easy to mark a task as done

Great for quickly going through the to-do list. Gets rid of one
extra keystroke. ;)

#+begin_src emacs-lisp
(defun sacha/org-agenda-done (&optional arg)
  "Mark current TODO as done.
This changes the line at point, all other lines in the agenda referring to
the same tree node, and the headline of the tree node in the Org-mode file."
  (interactive "P")
  (org-agenda-todo "DONE"))
;; Override the key definition for org-exit
(define-key org-agenda-mode-map "x" 'sacha/org-agenda-done)
#+end_src

**** Make it easy to mark a task as done and create a follow-up task

#+begin_src emacs-lisp
  (defun sacha/org-agenda-mark-done-and-add-followup ()
    "Mark the current TODO as done and add another task after it.
Creates it at the same level as the previous task, so it's better to use
this with to-do items than with projects or headings."
    (interactive)
    (org-agenda-todo "DONE")
    (org-agenda-switch-to)
    (org-capture 0 "t"))
;; Override the key definition
(define-key org-agenda-mode-map "X" 'sacha/org-agenda-mark-done-and-add-followup)
#+end_src

**** Capture something based on the agenda

#+begin_src emacs-lisp
(defun sacha/org-agenda-new ()
  "Create a new note or task at the current agenda item.
Creates it at the same level as the previous task, so it's better to use
this with to-do items than with projects or headings."
  (interactive)
  (org-agenda-switch-to)
  (org-capture 0))
;; New key assignment
(define-key org-agenda-mode-map "N" 'sacha/org-agenda-new)
#+end_src

**** Starting my weeks on Saturday

I like looking at weekends as [[http://sachachua.com/blog/2010/11/week-beginnings/][week beginnings]] instead, so I want the
Org agenda to start on Saturdays.

#+begin_src emacs-lisp
(setq org-agenda-start-on-weekday 6)
#+end_src

**** Sorting by date and priority

#+begin_src emacs-lisp
  (setq org-agenda-sorting-strategy
        '((agenda time-up priority-down user-defined-up todo-state-up effort-up)
          (todo user-defined-up todo-state-up priority-down effort-down)
          (tags user-defined-up)
          (search category-keep)))
  (setq org-agenda-cmp-user-defined 'sacha/org-sort-agenda-items-user-defined)    
  (require 'cl)
  (defun sacha/org-get-context (txt)
    "Find the context."
    (car (member-if
          (lambda (item) (string-match "@" item))
          (get-text-property 1 'tags txt))))
  
  (defun sacha/org-compare-dates (a b)
    "Return 1 if A should go after B, -1 if B should go after A, or 0 if a = b."
    (cond
     ((and (= a 0) (= b 0)) nil)
     ((= a 0) 1)
     ((= b 0) -1)
     ((> a b) 1)
     ((< a b) -1)
     (t nil)))
  
  (defun sacha/org-complete-cmp (a b)
    (let* ((state-a (or (get-text-property 1 'todo-state a) ""))
           (state-b (or (get-text-property 1 'todo-state b) "")))
      (or
       (if (member state-a org-done-keywords-for-agenda) 1)
       (if (member state-b org-done-keywords-for-agenda) -1))))
  
  (defun sacha/org-date-cmp (a b)
    (let* ((sched-a (or (get-text-property 1 'org-scheduled a) 0))
           (sched-b (or (get-text-property 1 'org-scheduled b) 0))
           (deadline-a (or (get-text-property 1 'org-deadline a) 0))
           (deadline-b (or (get-text-property 1 'org-deadline b) 0)))
      (or
       (sacha/org-compare-dates
        (sacha/org-min-date sched-a deadline-a)
        (sacha/org-min-date sched-b deadline-b)))))
  
  (defun sacha/org-min-date (a b)
    "Return the smaller of A or B, except for 0."
    (funcall (if (and (> a 0) (> b 0)) 'min 'max) a b))
  
  (defun sacha/org-sort-agenda-items-user-defined (a b)
    ;; compare by deadline, then scheduled date; done tasks are listed at the very bottom
    (or
     (sacha/org-complete-cmp a b)
     (sacha/org-date-cmp a b)))
  
  (defun sacha/org-context-cmp (a b)
    "Compare CONTEXT-A and CONTEXT-B."
    (let ((context-a (sacha/org-get-context a))
          (context-b (sacha/org-get-context b)))
      (cond
       ((null context-a) +1)
       ((null context-b) -1)
       ((string< context-a context-b) -1)
       ((string< context-b context-a) +1)
       (t nil))))
  
  (defun sacha/org-sort-agenda-items-todo (a b)
    (or
     (org-cmp-time a b)
     (sacha/org-complete-cmp a b)
     (sacha/org-context-cmp a b)
     (sacha/org-date-cmp a b)
     (org-cmp-todo-state a b)
     (org-cmp-priority a b)
     (org-cmp-effort a b)))
#+end_src
     
**** Preventing things from falling through the cracks
This helps me keep track of unscheduled tasks, because I sometimes
forget to assign tasks a date. I also want to keep track of stuck projects.
#+begin_src emacs-lisp
(defun sacha/org-agenda-list-unscheduled (&rest ignore)
  "Create agenda view for tasks that are unscheduled and not done."
  (let* ((org-agenda-todo-ignore-with-date t)
	 (org-agenda-overriding-header "List of unscheduled tasks: "))
    (org-agenda-get-todos)))
(setq org-stuck-projects
      '("+PROJECT-MAYBE-DONE"
        ("TODO")
        nil
        "\\<IGNORE\\>"))
#+end_src

*** Weekly review

List upcoming tasks so that I can see if I'm overloaded.

#+begin_src emacs-lisp
  (defun sacha/org-summarize-upcoming-week ()
    "Summarize upcoming tasks as a list."
    (interactive)
    (org-agenda nil "w")
    (let ((string (buffer-string))
          business relationships life)
      (with-temp-buffer
        (insert string)
        (goto-char (point-min))
        (while (re-search-forward "^  \\([^:]+\\): +\\(Sched[^:]+: +\\)?TODO \\(.*?\\)\\(?:[      ]+\\(:[[:alnum:]_@#%:]+:\\)\\)?[        ]*$" nil t)
          (cond
           ((string= (match-string 1) "routines") nil) ; skip routine tasks
           ((string= (match-string 1) "business")
            (add-to-list 'business (concat "  - [ ] " (match-string 3))))
           ((string= (match-string 1) "people")
            (add-to-list 'relationships (concat "  - [ ] " (match-string 3))))
           (t (add-to-list 'life (concat "  - [ ] " (match-string 3)))))))
      (setq string
            (concat
        "*Plans for next week*\n"
        "- Business\n"
        (mapconcat 'identity business "\n")
        "\n- Relationships\n"
        (mapconcat 'identity relationships "\n")
        "\n- Life\n"
        (mapconcat 'identity life "\n")))
      (if (called-interactively-p)
          (kill-new string)
        string)))
#+end_src

This uses Org Agenda's log mode to summarize the tasks that I checked
off. I still need to match it up with the plans for the previous week
to see which items I'd planned ahead, and which ones were new tasks.
(Hmm, is it important to track those separately? I might just skip it.)

#+begin_src emacs-lisp
  (defun sacha/org-summarize-previous-week ()
    "Summarize previously-completed tasks as a list."
    (interactive)
    (save-window-excursion
      (org-agenda nil "w")
      (org-agenda-later -1)
      (org-agenda-log-mode 16)
      (let ((string (buffer-string))
            business relationships life)
        (with-temp-buffer
          (insert string)
        (goto-char (point-min))
        (while (re-search-forward "^  \\([^:]+\\): +.*?State:.*?\\(?:TODO\\|DONE\\) \\(.*?\\)\\(?:[       ]+\\(:[[:alnum:]_@#%:]+:\\)\\)?[        ]*$" nil t)
          (cond
           ((string= (match-string 1) "routines") nil) ; skip routine tasks
           ((string= (match-string 1) "business")
            (add-to-list 'business (concat "  - " (match-string 2))))
           ((string= (match-string 1) "people")
            (add-to-list 'relationships (concat "  - " (match-string 2))))
           (t (add-to-list 'life (concat "  - " (match-string 2)))))))
      (setq string
            (concat
             "*Accomplished this week*\n\n"
             "- Business\n"
             (mapconcat 'identity business "\n")
             "\n- Relationships\n"
             (mapconcat 'identity relationships "\n")
             "\n- Life\n"
             (mapconcat 'identity life "\n")))
      (if (called-interactively-p)
          (kill-new string)
        string))))
#+end_src

I use this to put together a quick summary of how I spent my time.

#+begin_src emacs-lisp
    (defvar sacha/org-quantified-categories 
      '(("Business" 
         ("E1" . "Business - Consulting - E1") 
         ("Connect" . "Business - Connect") 
         ("Drawing" . "Business - Drawing") 
         ("Illustration" . "Business - Illustration") 
         ("Coding" . "Business - Coding"))
        ("Discretionary" ("Emacs" . "Discretionary - Emacs")
         ("Social" . "Discretionary - Social")
         ("Writing" . "Discretionary - Writing"))
        ("Personal" ;("Biking" . "Personal - Bike")
         ("Routines" . "Personal - Routines"))
        ("Sleep" nil)
        ("Unpaid work" 
         ("Commuting" . "Unpaid work - Subway")
         ("Cook" . "Unpaid work - Cook")
         ("Tidy" . "Unpaid work - Tidy up")))
      "Categories for time summary.")
    (defun sacha/org-summarize-time-use (&optional start end)
      (require 'quantified)
      (interactive)
      (unless start (setq start (format-time-string "%Y-%m-%d" (days-to-time (- (time-to-number-of-days base-date) 6)))))
      (unless end (setq end (format-time-string "%Y-%m-%d" (days-to-time (1+ (time-to-number-of-days base-date))))))
      (let ((time-summary (quantified-summarize-time start end))
            (categories sacha/org-quantified-categories)
            result)
        (setq result
              (mapconcat
               (lambda (a)
                 (if (assoc (car a) time-summary)
                     (concat
                      (format "- %s: %.1f hours" (car a) (/ (cdr (assoc (car a) time-summary)) 3600.0))
                      (if (cdr a)
                          (let ((detail
                                 (delq nil
                                       (mapcar (lambda (b)
                                                 (if (assoc (cdr b) time-summary)
                                                     (format "%s: %.1f"
                                                             (car b)
                                                             (/ (cdr (assoc (cdr b) time-summary)) 3600.0))
                                                   nil))
                                               (cdr a)))))
                            (if detail
                                (concat " (" (mapconcat 'identity detail ", ") ")")
                              ""))
                        "")
                      (if (string-equal (car a) "Sleep")
                          (format " - average of %.1f hours per day" (/ (cdr (assoc (car a) time-summary)) 3600.0 7.0))
                        "")
                      "\n")))
         categories ""))
  (if (called-interactively-p)
      (insert result)
    result)))
    #+end_src

Now we put it all together...

#+begin_src emacs-lisp
  (defun sacha/org-prepare-weekly-review ()
    "Prepare weekly review template."
    (interactive)
    (let ((base-date (apply 'encode-time (org-read-date-analyze "-fri" nil '(0 0 0))))
          (org-agenda-files '("~/personal/organizer.org" "~/personal/business.org" "~/personal/people.org")))
      (save-window-excursion
        (kill-new
         (concat
          "**** Weekly review: Week ending " (format-time-string "%B %e, %Y" base-date) "  :weekly:\n"
          "*Blog posts*\n\n"
          (sacha/org-summarize-previous-week)
          "\n"
          (sacha/org-summarize-upcoming-week)
          "\n*Time review*\n"
          (sacha/org-summarize-time-use
           (format-time-string "%Y-%m-%d" (days-to-time (- (time-to-number-of-days base-date) 6)))
           (format-time-string "%Y-%m-%d" (days-to-time (1+ (time-to-number-of-days base-date)))))
          "\n")))
      (yank)))
#+end_src

*** Viewing, navigating, and editing the Org tree

    #+begin_src emacs-lisp
      (setq org-cycle-include-plain-lists nil)
    #+end_src

    I often cut and paste subtrees. This makes it easier to cut
    something and paste it elsewhere in the hierarchy.
    #+begin_src emacs-lisp
      (eval-after-load 'org
        '(progn
           (define-key org-mode-map (kbd "C-c k") 'org-cut-subtree)
           (setq org-yank-adjusted-subtrees t)))
#+end_src
*** Publishing
Timestamps and section numbers make my published files look more
complicated than they are. Let's turn them off by default.
#+begin_src emacs-lisp
(setq org-export-with-section-numbers nil)
(setq org-html-include-timestamps nil)
#+end_src

This makes it easier to publish my public Dropbox files:

#+begin_src emacs-lisp
  (require 'org-publish)
  (setq org-publish-project-alist
        '(("public"
           :base-directory "c:/sacha/Dropbox/public"
           :base-extension "org"
           :publishing-directory "c:/sacha/Dropbox/public"
           :publishing-function org-publish-org-to-html
           )))
#+end_src

I use org2blog to post to my blog, which is Wordpress-based. I used to
use punchagan's org2blog, but there's a completely different one in
ELPA, so I figured I'd give that a try.

#+begin_src emacs-lisp
(sacha/package-install 'org2blog)
(require 'org2blog-autoloads)
(setq org-export-with-toc nil)
(setq org-export-htmlize-output-type 'css)
#+end_src

Might as well take advantage of my stylesheet:

#+begin_src emacs-lisp
(setq org-export-html-style "<link rel=\"stylesheet\" type=\"text/css\" href=\"http://sachachua.com/blog/wp-content/themes/sacha-v3/style.css\" />
<link rel=\"stylesheet\" type=\"text/css\" href=\"http://sachachua.com/org-export.css\" />")
(setq org-export-html-preamble nil)
(setq org-export-html-postamble nil)
(setq org-src-fontify-natively t)
#+end_src

Sometimes I just want a little bit:

#+begin_src emacs-lisp
(defun sacha/org-export-subtree-as-html-fragment ()
  (interactive)
  (org-export-region-as-html
   (org-back-to-heading)
   (org-end-of-subtree)
   t))
#+end_src

*** Structure templates

Org makes it easy to insert blocks by typing <s[TAB], etc.
I hardly ever use LaTeX, but I insert a lot of Emacs Lisp blocks, so I
redefine <l to insert a Lisp block instead.

#+begin_src emacs-lisp
  (setq org-structure-template-alist 
        '(("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
          ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
          ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
          ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
          ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER" "<center>\n?\n</center>")
          ("l" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"emacs-lisp\">\n?\n</src>")
          ("L" "#+latex: " "<literal style=\"latex\">?</literal>")
          ("h" "#+begin_html\n?\n#+end_html" "<literal style=\"html\">\n?\n</literal>")
          ("H" "#+html: " "<literal style=\"html\">?</literal>")
          ("a" "#+begin_ascii\n?\n#+end_ascii")
          ("A" "#+ascii: ")
          ("i" "#+index: ?" "#+index: ?")
          ("I" "#+include %file ?" "<include file=%file markup=\"?\">")))
#+end_src
*** Quick links
    #+begin_src emacs-lisp
    (setq org-link-abbrev-alist
      '(("google" . "http://www.google.com/search?q=")
	("gmap" . "http://maps.google.com/maps?q=%s")
	("blog" . "http://sachachua.com/blog/p/")))
#+end_src
*** MobileOrg for Android

    I've been playing around with MobileOrg so that I can review my
    agenda and capture notes on my smartphone. My main Org file is too
    big to open easily there, though.
    
#+begin_src emacs-lisp
    (use-package org-mobile
      :init
      (progn
        (autoload 'org-mobile-pull "org-mobile" nil t)
        (autoload 'org-mobile-push "org-mobile" nil t))
      :config
      (progn
        (setq org-mobile-directory "~/Dropbox/mobile")
        (setq org-mobile-inbox-for-pull "~/personal/mobileorg.org")
        (setq default-buffer-file-coding-system 'utf-8)
        (setq org-mobile-files '("/cygdrive/c/sacha/personal/organizer.org" "/cygdrive/c/sacha/personal/business.org" "/cygdrive/c/sacha/personal/books.org"))
        (setq org-mobile-agendas '("a"))))
#+end_src
*** Clocking
Too many clock entries clutter up a heading.
#+begin_src emacs-lisp
(setq org-log-into-drawer "LOGBOOK")
(setq org-clock-into-drawer 1)
#+end_src
*** Idle timer

This snippet is from John Wiegley -
http://lists.gnu.org/archive/html/emacs-orgmode/2010-03/msg00367.html.
It shows the org agenda when Emacs is idle.

Thanks to winner-mode, I can get back to my previous buffers with C-c
left.
#+begin_src emacs-lisp
(defun jump-to-org-agenda ()
  (interactive)
  (let ((buf (get-buffer "*Org Agenda*"))
        wind)
    (if buf
        (if (setq wind (get-buffer-window buf))
            (select-window wind)
          (if (called-interactively-p)
              (progn
                (select-window (display-buffer buf t t))
                (org-fit-window-to-buffer)
                ;; (org-agenda-redo)
                )
            (with-selected-window (display-buffer buf)
              (org-fit-window-to-buffer)
              ;; (org-agenda-redo)
              )))
      (call-interactively 'org-agenda-list)))
  ;;(let ((buf (get-buffer "*Calendar*")))
  ;;  (unless (get-buffer-window buf)
  ;;    (org-agenda-goto-calendar)))
  )

(run-with-idle-timer 300 t 'jump-to-org-agenda)

#+end_src
*** Speed commands
#+begin_src emacs-lisp
(add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
(add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
(add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
#+end_src
*** My files

#<<org-files>>

Here are the Org files I use. I should probably organize them better. =)

| organizer.org   | My main Org file. Inbox for M-x org-capture, tasks, weekly reviews, etc.           |
| emacs.org       | Interesting Emacs snippets. Used to be in outline.org, but got to be pretty big    |
| business.org    | Business-related notes and TODOs                                                   |
| decisions.org   | Pending, current, and reviewed decisions                                           |
| outline.org     | Huge outline of notes by category                                                  |
| tracking.org    | Temporary Org file for tracking various things                                     |
| delegation.org  | Templates for assigning tasks                                                      |
| books.org       | Huge file with book notes                                                          |
| calendar.org    | Used to use this with ical2org, but have been having problems with ical2org lately |
| contacts.org    | People-related notes using org-contacts                                            |
| blog.org        | Topic index for my blog                                                            |
| t420.org        | Miscellaneous notes related to old projects                                        |
| learning.org    | Learning plan                                                                      |
| ideal.org       | Planning ideal days                                                                |
| archive.org     | Archived subtrees                                                                  |
| latin.org       | Latin notes                                                                        |
| preparation.org | Things I think about and plan ahead for, so that I can be less nervous about them. |
| 101things.org   | Old goals for 101 things in 1001 days                                              |
| org-talk.org    | Notes for my talk in Org                                                           |
| life.org        | Questions, processes, tools                                                        |
| quotes.org      | Quotations                                                                         |

** Coding
*** General preferences
    #+begin_src emacs-lisp
    (setq tab-width 4)
#+end_src
*** Use Cygwin
#+begin_src emacs-lisp
  ;(setenv "PATH" (concat "c:/cygwin/bin;" (getenv "PATH")))
  ;(add-to-list 'exec-path "c:/cygwin/bin/" t) 
  ;(require 'cygwin-mount)
  ;(cygwin-mount-activate)
  (add-hook 'comint-output-filter-functions
      'shell-strip-ctrl-m nil t)
  (add-hook 'comint-output-filter-functions
      'comint-watch-for-password-prompt nil t)
  ;(setq explicit-shell-file-name "cmdproxy.exe")
  ;(setq explicit-shell-file-name "bash.exe")
  ;; For subprocesses invoked via the shell
  ;; (e.g., "shell -c command")
  ;(setq shell-file-name explicit-shell-file-name)
#+end_src
*** Drupal

#+begin_src emacs-lisp
  (define-derived-mode drupal-mode php-mode "Drupal"
    "Major mode for Drupal source code.
  \\{drupal-mode-map}"
    (setq case-fold-search t) 
    (setq indent-tabs-mode nil)
    (setq c-basic-offset 2)
    (setq indent-tabs-mode nil)
    (setq tab-width 2)
    (setq fill-column 78)
    (c-set-offset 'arglist-cont 0)
    (c-set-offset 'arglist-intro '+)
    (c-set-offset 'case-label 2)
    (c-set-offset 'arglist-close 0)
    (setq yas/buffer-local-condition 
    '(cond
     ((looking-at "\\w") nil)
     ((and
       (not (bobp))
       (or (equal "font-lock-comment-face"
                  (get-char-property (1- (point)) 'face))
           (equal "font-lock-string-face"
                  (get-char-property (1- (point)) 'face))))
      '(require-snippet-condition . force-in-comment))
     (t t))))
  (define-key drupal-mode-map (kbd "TAB") 'indent-according-to-mode)
  (add-hook 'drupal-mode-hook (lambda () (flymake-mode 1)))
  (add-hook 'drupal-mode-hook (lambda () (yas/minor-mode 1)))
  (add-to-list 'auto-mode-alist '("\\.\\(php\\|test\\|module\\|inc\\|install\\|engine\\|profile\\|.theme\\)$" . drupal-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl.php$" . html-helper-mode))
  (define-key drupal-mode-map '[M-S-up] 'flymake-goto-prev-error)
  (define-key drupal-mode-map '[M-S-down] 'flymake-goto-next-error)
  (define-key drupal-mode-map (kbd "C-c C-c") 'comment-dwim)
  
  (defun sacha/drupal-module-name ()
    "Return the Drupal module name for .module and .install files."    (file-name-sans-extension (file-name-nondirectory
                               (buffer-file-name))))
  (add-to-list 'hs-special-modes-alist '(drupal-mode "{" "}" "/[*/]" nil hs-c-like-adjust-block-beginning))
  
#+end_src

*** Expand region
#+begin_src emacs-lisp
  (sacha/package-install 'expand-region)
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+end_src
*** Tag files
    I don't want to have to set my tags file per project, so I search
    for it in the directory tree instead.
    
    #+begin_src emacs-lisp
      (defun sacha/recursive-find-file (file &optional directory)
        "Find the first FILE in DIRECTORY or its parents."
        (setq directory (or directory (file-name-directory (buffer-file-name)) (pwd)))
        (if (file-exists-p (expand-file-name file directory))
            (expand-file-name file directory)
          (unless (string= directory "/")
            (sacha/recursive-find-file file (expand-file-name ".." directory)))))
      
      (defun sacha/find-tags ()
        "Set the TAGS file."
        (set (make-variable-buffer-local 'tags-table-list) nil)
        (set (make-variable-buffer-local 'tags-file-name) 
             (sacha/recursive-find-file "TAGS")))
      
      (eval-after-load 'drupal-mode
        '(progn
           (add-hook 'drupal-mode-hook 'sacha/find-tags)))
      #+end_src

*** Emacs Lisp
**** Edebug

Did you know edebug has a trace function? I didn't. Thanks, agumonkey!

#+begin_src emacs-lisp
(setq edebug-trace t)
#+end_src

While edebugging, use T to view a trace buffer (=*edebug-trace*=).
Emacs will quickly execute the rest of your code, printing out the
arguments and return values for each expression it evaluates.

**** Eldoc
Eldoc provides minibuffer hints when working with Emacs Lisp.
#+begin_src emacs-lisp
    (autoload 'turn-on-eldoc-mode "eldoc" nil t)
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+end_src
**** Refactoring  :drill:
     SCHEDULED: <2013-03-03 Sun>
     :PROPERTIES:
     :ID:       99ac7ddb-08ef-46c4-8fa8-8a45164f9ef4
     :DRILL_LAST_INTERVAL: 3.86
     :DRILL_REPEATS_SINCE_FAIL: 2
     :DRILL_TOTAL_REPEATS: 2
     :DRILL_FAILURE_COUNT: 1
     :DRILL_AVERAGE_QUALITY: 2.5
     :DRILL_EASE: 2.36
     :DRILL_LAST_QUALITY: 3
     :DRILL_LAST_REVIEWED: [2013-02-27 Wed 21:18]
     :END:

#+begin_src emacs-lisp
;; C-c C-v l : elint current buffer in clean environment.
;; C-c C-v L : elint current buffer by multiple emacs binaries.
;;             See `erefactor-lint-emacsen'
;; C-c C-v r : Rename symbol in current buffer.
;;             Resolve `let' binding as long as i can.
;; C-c C-v R : Rename symbol in requiring modules and current buffer.
;; C-c C-v h : Highlight current symbol in this buffer
;;             and suppress `erefacthr-highlight-mode'.
;; C-c C-v d : Dehighlight all by above command.
;; C-c C-v c : Switch prefix bunch of symbols.
;;             ex: '(hoge-var hoge-func) -> '(foo-var foo-func)
;; C-c C-v ? : Display flymake elint warnings/errors

  (use-package erefactor
    :config
    (define-key emacs-lisp-mode-map "\C-c\C-v" erefactor-map))
#+end_src
**** Jumping to code

#+begin_src emacs-lisp
(define-key emacs-lisp-mode-map (kbd "C-c .") 'find-function-at-point)
#+end_src
*** Snippets
    #+begin_src emacs-lisp
      (use-package yasnippet-bundle
        :init
        (progn
          (yas/initialize)
          (yas/load-directory "~/elisp/snippets")
          (setq yas/key-syntaxes '("w_" "w_." "^ "))))
      ;;        (global-set-key (kbd "C-c y") (lambda () (interactive)
      ;;                                         (yas/load-directory "~/elisp/snippets")))
#+end_src
*** Show more information

I sometimes need to know where I am in a line.
    #+begin_src emacs-lisp
(column-number-mode 1)
#+end_src

*** Don't show whitespace in diff, but show context
    #+begin_src emacs-lisp
    (setq vc-diff-switches '("-b" "-B" "-u"))
#+end_src
*** Javascript
#+begin_src emacs-lisp
  (use-package js2-mode
    :commands js2-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode)))
#+end_src
** Ledger (personal finance)

This isn't a package yet, so I manually load it when I want to.

*** Make it easier to review my credit card transactions

#+begin_src emacs-lisp
(defun sacha/ledger-go-to-beginning-of-entry ()
  "Move to the beginning of the current entry."
  (while (and (not (bobp))
              (eq (ledger-context-line-type (ledger-context-at-point))
                  'acct-transaction))
    (forward-line -1)))

(defun sacha/ledger-entry-date ()
  "Returns the date of the entry containing point or nil."
  (save-excursion
    (sacha/ledger-go-to-beginning-of-entry)
    (let ((context-info (ledger-context-other-line 0)))
      (when (eq (ledger-context-line-type context-info) 'entry)
        (goto-char (line-beginning-position))
        (if (looking-at "\\([-0-9\\./]+\\)")
            (match-string-no-properties 1))))))

(defun sacha/ledger-guess-mbna ()
  "Adds a sub-account for the dates for my credit card transactions."
  (interactive)
  (save-excursion
    (sacha/ledger-go-to-beginning-of-entry)
    (forward-line 1)
    (let ((amount 0) (date (sacha/ledger-entry-date)) month)
      (if (string-match "[0-9]+[-\\.]\\([0-9]+\\)[-\\.]\\([0-9]+\\)" date)
          (setq month (string-to-number (match-string 1 date))))
      ;; Is this a payment or a charge?
      (save-excursion
        (while (and (eq (ledger-context-line-type (ledger-context-at-point))
                        'acct-transaction)
                    (not (eobp)))
          (let ((context (ledger-context-at-point)))
            (if (ledger-context-field-value context 'amount)
                (if (string-match "MBNA" (ledger-context-field-value context 'account))
                    (setq amount (string-to-number (ledger-context-field-value context 'amount)))
                  (setq amount (- (string-to-number (ledger-context-field-value context 'amount)))))))
          (forward-line 1)))
      (save-excursion
        (while (and (eq (ledger-context-line-type (ledger-context-at-point))
                        'acct-transaction)
                    (not (eobp)))
          (let ((context (ledger-context-at-point)))
            (if (string-match "MBNA" (ledger-context-field-value context 'account))
                (if (re-search-forward "\\(MBNA\\)[ \t]*[-$\.0-9]*[ \t]*$" (line-end-position) t)
                    (replace-match
                     (concat "MBNA:"
                             (elt
                              '("January" "February" "March" "April" "May" "June" "July" "August" "September" "October" "November" "December")
                              (% (+ (if (> amount 0) 10 11) month) 12)))
                             t t nil 1))))
          (forward-line 1))))))
#+end_src

** Fun and games

*** Typing of Emacs
    #+begin_src emacs-lisp
      (use-package typing
        :init
        (autoload 'typing-of-emacs "typing" nil t)
        :config
        (progn
          (setq toe-starting-length 6)
          (setq toe-starting-time-per-word 2)
          (setq toe-max-length 20)))
#+end_src
*** Internet Relay Chat

    IRC is a great way to hang out with other Emacs geeks.
    #+begin_src emacs-lisp
      (use-package erc
        :config
        (setq erc-autojoin-channels-alist '(("freenode.net"
                                             "#org-mode"
                                             "#hacklabto"
                                             "#emacs"
                                             "#emacsconf"))
              erc-server "irc.freenode.net"
              erc-nick "sachac"))
    #+end_src

*** Keywiz - keyboard quizzes
#+begin_src emacs-lisp
  (use-package keywiz)
  (defun sacha/load-keybindings ()
    "Since we don't want to have to pass through a keywiz game each time..."
    (setq keywiz-cached-commands nil)
    (do-all-symbols (sym)
      (when (and (commandp sym)
                 (not (memq sym '(self-insert-command
                                  digit-argument undefined))))
        (let ((keys (apply 'nconc (mapcar
                                   (lambda (key)
                                     (when (keywiz-key-press-event-p key)
                                       (list key)))
                                   (where-is-internal sym)))))
          ;;  Politically incorrect, but clearer version of the above:
          ;;    (let ((keys (delete-if-not 'keywiz-key-press-event-p
          ;;                               (where-is-internal sym))))
          (and keys
               (push (list sym keys) keywiz-cached-commands))))))
  (sacha/load-keybindings)
  ;; Might be good to use this in org-agenda...
  (defun sacha/random-keybinding ()
    "Describe a random keybinding."
    (let* ((command (keywiz-random keywiz-cached-commands))
           (doc (and command (documentation (car command)))))
      (if command
          (concat (symbol-name (car command)) " "
                  "(" (mapconcat 'key-description (cadr command) ", ") ")"
                  (if doc
                      (concat ": " (substring doc 0 (string-match "\n" doc)))
                    ""))
        "")))
#+end_src
** Statistics and data transformations
*** R

#+begin_src emacs-lisp
  (sacha/package-install 'ess)                
  (use-package ess-site
    :init (setq inferior-R-program-name "c:/progra~1/R/R-2.15.0/bin/x64/Rterm.exe")
    :commands R)
#+end_src

*** Artrage

#+begin_src emacs-lisp
          (defun sacha/artrage-export-png (directory &optional prefix)
            "Change an Artrage script file (arscript) to export images to DIRECTORY. 
      If PREFIX is specified, use that instead of image-."
            (interactive "MPath: ")
            (unless (file-directory-p directory)
              (make-directory directory t))
            (while (re-search-forward "[0-9\\.]+s" nil t)
              (replace-match "0.000s"))
            (goto-char (point-min))
            (while (search-forward "<StrokeEvent>" nil t)
              (replace-match (concat 
                              "EvType: Command    CommandID: ExportLayer    Idx: -1    Channels: NO    Path: \""
                              directory
                              "/" (or prefix "image-")
                              ".png\"
  <StrokeEvent>") t t)))
    
#+end_src
*** Workrave
    #+begin_src emacs-lisp
    (defvar sacha/workrave-file (expand-file-name ".\\Workrave\\historystats" (getenv "AppData")))

(defun sacha/workrave-transform-statistics (&optional file)
  (interactive (list sacha/workrave-file))
  (with-current-buffer (find-file-noselect file)
  ;; D day month-1 year hour min day month-1 year hour min
    (let ((result "Date\tStart\tEnd\tClicks\tKeystrokes\n"))
      (goto-char (point-min))
      (while (re-search-forward "^D \\(.*\\)" nil t)
	(let ((dates (split-string (match-string 1))))
	  (if (re-search-forward "^m \\(.*\\)" nil t)
	      (let ((info (split-string (match-string 1))))
		(setq result
		      (concat result
			      (format "%d-%d-%s\t%s:%02d\t%s:%02d\t%s\t%s\n"
				      (+ 1900 (string-to-number (elt dates 2))) ; year
				      (1+ (string-to-number (elt dates 1))) ; month
				      (elt dates 0) ; day
				      (elt dates 3) ; start hour
				      (string-to-number (elt dates 4)) ; start min
				      (elt dates 8) ; end hour
				      (string-to-number (elt dates 9)) ; end min
				      (elt info 5) ; clicks
				      (elt info 6) ; keystrokes
				      )))))))
      (if (interactive-p)
	  (kill-new result)
	result))))
    #+end_src
*** Blog
#+begin_src emacs-lisp
    (defun sacha/strip-blog-share ()
      (interactive)
      (let (base)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward "<div class=\"sharedaddy sd-sharing-enabled\">.*?<div class=\"sharing-clear\"></div></div></div></div>" nil t)
            (replace-match "")))))
#+end_src
** Quantified Awesome

#+begin_src emacs-lisp
  (use-package quantified
    :init
    (defun sacha/org-quantified-track (category)
      "Create a tracking record using CATEGORY.
  Default to the current task in the agenda, the currently-clocked
  entry, or the current subtree in Org."
      (interactive
       (list
        (read-string "Category: "
                     (or
                      (if (derived-mode-p 'org-agenda-mode)
                          (let* ((marker (org-get-at-bol 'org-marker))
                                 (buffer (marker-buffer marker))
                                 (pos (marker-position marker)))
                          (with-current-buffer buffer
                            (save-excursion
                              (save-restriction
                                (widen)
                                (goto-char pos)
                                (org-entry-get-with-inheritance "QUANTIFIED"))))))       
                    (if org-clock-marker
                        (save-excursion
                          (org-clock-goto)
                          (org-entry-get-with-inheritance "QUANTIFIED")))
                    (if (derived-mode-p 'org-mode)
                        (org-entry-get-with-inheritance "QUANTIFIED"))))))))
#+end_src
** Workarounds
*** color-theme sometimes comes across lists. Odd!

#+begin_src emacs-lisp
  (defadvice face-attribute (around sacha activate)
    (if (symbolp (ad-get-arg 0))
        ad-do-it))
#+end_src

*** ido-sort-mtime stopped working when I upgraded to Windows 8

#+begin_src emacs-lisp
  (defadvice ido-sort-mtime (around sacha activate)
    (setq ido-temp-list
          (sort ido-temp-list 
                (lambda (a b)
                  (let ((ta (or (nth 5 (file-attributes (concat ido-current-directory a))) '(0 0)))
                        (tb (or (nth 5 (file-attributes (concat ido-current-directory b))) '(0 0))))
                    (if (= (nth 0 ta) (nth 0 tb))
                        (> (nth 1 ta) (nth 1 tb))
                      (> (nth 0 ta) (nth 0 tb)))))))
    (setq ad-return-value
          (ido-to-end  ;; move . files to end (again)
           (delq nil (mapcar
                      (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                      ido-temp-list)))))
  
#+end_src
*** Cygwin mogrify doesn't work for me, but ImageMagick does

#+begin_src emacs-lisp
;(setq eimp-mogrify-program "c:/Program Files/ImageMagick-6.8.3-Q16/mogrify.exe")
#+end_src

** Startup
   #+begin_src emacs-lisp
     (find-file "~/personal/organizer.org")
     (require 'org-compat)
     (org-agenda nil "a")
#+end_src
** Autoconnect to IRC so that I don't forget

#+begin_src emacs-lisp
(erc :server "irc.freenode.net" :port 6667 :nick "sachac")
#+end_src

* Inactive/infrequent things
** Presentation code for Emacs Conference
<<emacsconf2013>>

#+begin_src  :eval no :tangle no
  (defvar sacha/org-show-presentation-file "~/Dropbox/Emacs Conference/public.org" "File containing the presentation.")
  (defvar sacha/org-show-slide-tag "slide" "Tag that marks slides.")
  (defvar sacha/org-show-slide-tag-regexp (concat ":" (regexp-quote sacha/org-show-slide-tag) ":"))
  (require 'eimp)
    
  ;; From org-pres--eimp-fit
  (defun sacha/org-show-eimp-fit ()
    "Function used as a hook, fits the image found to the window."
    (when (eq major-mode 'image-mode)
      (eimp-fit-image-to-window nil)))
  (add-hook 'find-file-hook 'sacha/org-show-eimp-fit)
  
  (defun sacha/org-show-execute-slide ()
    "Process slide at point.
    If it contains an Emacs Lisp source block, evaluate it.
    If it contains an image, view it and switch to that buffer.
    Else, focus on that buffer.
    Hide all drawers."
    (interactive)
    (find-file sacha/org-show-presentation-file)
    (org-narrow-to-subtree)
    (visual-line-mode)
    (let ((heading-text (nth 4 (org-heading-components))))
      (cond
       ;; view images
       ((and (goto-char (point-min))
             (re-search-forward "\\[\\[.*\\.\\(jpg\\|gif\\|png\\)" nil t))
        (delete-other-windows)
        (let ((org-link-frame-setup '((file . find-file))))
          (org-open-at-point))
        (delete-other-windows)
        (goto-char (point-min)))
       ;; find and execute source code blocks
       ((and (goto-char (point-min))
             (re-search-forward "#\\+begin_src" nil t))
        (let ((info (org-babel-get-src-block-info)))
          (unwind-protect
              (eval (read (concat "(progn " (nth 1 info) ")"))))))
       (t
        (switch-to-buffer (current-buffer))
        (text-scale-set 4)
        (org-show-subtree)
        (org-cycle-hide-drawers t)
        (org-display-inline-images)
        (delete-other-windows)))
      (set-frame-name heading-text)))
  
  (defun sacha/org-show-next-slide ()
    "Show the next slide."
    (interactive)
    (find-file sacha/org-show-presentation-file)
    (widen)
    (goto-char (line-end-position))
    (when (re-search-forward sacha/org-show-slide-tag-regexp nil t)
      (sacha/org-show-execute-slide)))
  
  (defun sacha/org-show-previous-slide ()
    "Show the next slide."
    (interactive)
    (find-file sacha/org-show-presentation-file)
    (widen)
    (goto-char (line-beginning-position))
    (when (re-search-backward sacha/org-show-slide-tag-regexp nil t)
      (sacha/org-show-execute-slide)))
  
  (global-set-key '[f5] 'sacha/org-show-previous-slide)
  (global-set-key '[f6] 'sacha/org-show-execute-slide)
  (global-set-key '[f7] 'sacha/org-show-next-slide)
#+end_src

** Enable minibuffer completion
[2013-03-31] Superseded by ido-hacks?

It can be difficult to remember the full names of Emacs commands, so I
use =icomplete-mode= for minibuffer completion. This also makes it
easier to discover commands.

#+begin_src emacs-lisp :eval no :tangle no
(icomplete-mode 1)
#+end_src

** Because I'm trying to use helm instead of ido...
*** Ido-mode: Much better navigationy things
[2013-03-31]: Let's try using Helm instead.

Ido-mode is awesome. Let's make it awesomer. I usually want to go to
recently-opened files first.

#+begin_src emacs-lisp :eval no :tangle no
(use-package ido
  :init
  (progn
  (ido-mode 1)
  (setq ido-default-buffer-method 'selected-window)
  (add-hook 'ido-make-file-list-hook 'ido-sort-mtime)
  (add-hook 'ido-make-dir-list-hook 'ido-sort-mtime)
  (defun ido-sort-mtime ()
    (setq ido-temp-list
          (sort ido-temp-list 
                (lambda (a b)
                  (let ((ta (nth 5 (file-attributes (concat ido-current-directory a))))
                        (tb (nth 5 (file-attributes (concat ido-current-directory b)))))
                    (if (= (nth 0 ta) (nth 0 tb))
                        (> (nth 1 ta) (nth 1 tb))
                      (> (nth 0 ta) (nth 0 tb)))))))
    (ido-to-end  ;; move . files to end (again)
     (delq nil (mapcar
                (lambda (x) (if (string-equal (substring x 0 1) ".") x))
                ido-temp-list))))))
#+end_src

*** Ido and Org
     
     When I use =org-refile= to organize my notes, I like seeing the
     latest entries on top. Ido-related and verify-related snippets
     are from "Using ido-mode for org-refile (and archiving via
     refile)" in [[http://orgmode.org/worg/org-hacks.html][Org Hacks]].
     
     #+begin_src emacs-lisp :eval no :tangle no
         (setq ido-everywhere t)
         (setq ido-enable-flex-matching t)
         (setq ido-max-directory-size 100000)
         (ido-mode (quote both))
         (setq org-completion-us-ido t)
     #+end_src

*** Finding files

    I don't want to think about directory structures, I just want to
    open files. 

    #+begin_src emacs-lisp  :eval no :tangle no
      (require 'filecache)
      (require 'ido)
      (defun file-cache-ido-find-file (file)
        "Using ido, interactively open file from file cache'.
      First select a file, matched using ido-switch-buffer against the contents
      in `file-cache-alist'. If the file exist in more than one
      directory, select directory. Lastly the file is opened."
        (interactive (list (file-cache-ido-read "File: "
                                                (mapcar
                                                 (lambda (x)
                                                   (car x))
                                                 file-cache-alist))))
        (let* ((record (assoc file file-cache-alist)))
          (find-file
           (expand-file-name
            file
            (if (= (length record) 2)
                (car (cdr record))
              (file-cache-ido-read
               (format "Find %s in dir: " file) (cdr record)))))))
      
      (defun file-cache-ido-read (prompt choices)
        (let ((ido-make-buffer-list-hook
               (lambda ()
                 (setq ido-temp-list choices))))
          (ido-read-buffer prompt)))
      (add-to-list 'file-cache-filter-regexps "docs/html")
      (add-to-list 'file-cache-filter-regexps "\\.svn-base$")
      (add-to-list 'file-cache-filter-regexps "\\.dump$")
    #+end_src     

    To use this code, I add something like
    
    #+begin_src emacs-lisp :tangle no :eval no
      (sacha/file-cache-setup-tree "sacha/proj1" "C-c d"
                                   '("/dir1"
                                     "/dir2"))
    #+end_src
    to my config. Then =C-c d= (or whatever keyboard shortcut I use)
    searches for files within the specified directories.
    

** Work-in-progress: monthly review

... and for good measure, let's do some kind of monthly review too.

#+begin_src emacs-lisp :eval no :tangle no
  (defun sacha/org-prepare-monthly-review ()
    "Prepare monthly review template."
    (interactive)
    (let* ((base-date (org-read-date-analyze "-1m" nil '(0 0 0)))
           (start (encode-time 0 0 0 1 (elt base-date 4) (elt base-date 5)))
           (end (encode-time 0 0 0 1 (1+ (elt base-date 4)) (elt base-date 5)))
           (org-agenda-files '("~/personal/organizer.org" "~/personal/business.org" "~/personal/people.org")))
      (save-window-excursion
        (kill-new
         (concat
          "*** Monthly review: " (format-time-string "%B %Y" base-date) "  :monthly:\n"
          "*Blog posts*\n\n"
          "*Time review*\n"
          (sacha/org-summarize-time-use
           (format-time-string "%Y-%m-%d" start)
           (format-time-string "%Y-%m-%d" end)
           (float-time (time-subtract end start))
          "\n")))
      (yank))))
#+end_src

* Other nifty Emacs things I want to learn
** Finding the closest Makefile :drill:
   SCHEDULED: <2013-03-05 Tue>
   :PROPERTIES:
   :ID:       bfdaf129-f64c-49be-8848-a0e0300fdfdb
   :DRILL_LAST_INTERVAL: 4.14
   :DRILL_REPEATS_SINCE_FAIL: 2
   :DRILL_TOTAL_REPEATS: 1
   :DRILL_FAILURE_COUNT: 0
   :DRILL_AVERAGE_QUALITY: 5.0
   :DRILL_EASE: 2.6
   :DRILL_LAST_QUALITY: 5
   :DRILL_LAST_REVIEWED: [2013-03-01 Fri 16:47]
   :END:

Look up the directory hierarchy from FILE for a file named NAME.
Stop at the first parent directory containing a file NAME,
and return the directory.  Return nil if not found.

*** Answer
=find-dominating-file=


** iedit

#+begin_src emacs-lisp
(use-package iedit)
#+end_src
   
** Paredit  
   :PROPERTIES:
   :ID:       579d84bc-b5c2-496f-ab0e-64ed257daa51
   :END:
#+begin_src emacs-lisp  :eval no
  (use-package paredit
    :commands paredit-mode
    :init
    (add-hook 'emacs-lisp-mode-hook (lambda () (paredit-mode 1))))
#+end_src

Useful keybindings:
paredit-forward-slurp-sexp
paredit-forward-barf-sexp
paredit-backward-slurp-sexp
paredit-backward-barf-sexp
paredit-split-sexp
paredit-join-sexp
paredit-wrap-around 
*** Answer
paredit-forward-slurp-sexp C-), C-<right>
paredit-forward-barf-sexp C-<left>
paredit-backward-slurp-sexp C-M-<left>
paredit-backward-barf-sexp C-M-<right>
paredit-split-sexp M-S
paredit-join-sexp M-J
paredit-wrap-around C-(
** Smartparens mode :drill:

#+begin_src emacs-lisp
  (use-package smartparens
    :init 
    (progn
(require 'smartparens-config)
(add-hook 'emacs-lisp-mode-hook 'smartparens-mode)

;;;;;;;;;;;;;;;;;;;;;;;;
;; keybinding management

(define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
(define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)

(define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
(define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
(define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
(define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)

(define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
(define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
(define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
(define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)

(define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
(define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

(define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
(define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)

(define-key sp-keymap (kbd "M-<delete>") 'sp-unwrap-sexp)
(define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

(define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
(define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
(define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
(define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)

(define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
(define-key sp-keymap (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
(define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
(define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

(define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
(define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
(define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)

(define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
(define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)

(define-key sp-keymap (kbd "H-t") 'sp-prefix-tag-object)
(define-key sp-keymap (kbd "H-p") 'sp-prefix-pair-object)
(define-key sp-keymap (kbd "H-s c") 'sp-convolute-sexp)
(define-key sp-keymap (kbd "H-s a") 'sp-absorb-sexp)
(define-key sp-keymap (kbd "H-s e") 'sp-emit-sexp)
(define-key sp-keymap (kbd "H-s p") 'sp-add-to-previous-sexp)
(define-key sp-keymap (kbd "H-s n") 'sp-add-to-next-sexp)
(define-key sp-keymap (kbd "H-s j") 'sp-join-sexp)
(define-key sp-keymap (kbd "H-s s") 'sp-split-sexp)

;;;;;;;;;;;;;;;;;;
;; pair management

(sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)

;;; markdown-mode
(sp-with-modes '(markdown-mode gfm-mode rst-mode)
  (sp-local-pair "*" "*" :bind "C-*")
  (sp-local-tag "2" "**" "**")
  (sp-local-tag "s" "```scheme" "```")
  (sp-local-tag "<"  "<_>" "</_>" :transform 'sp-match-sgml-tags))

;;; tex-mode latex-mode
(sp-with-modes '(tex-mode plain-tex-mode latex-mode)
  (sp-local-tag "i" "1d5f8e69396c521f645375107197ea4dfbc7b792quot;<" "1d5f8e69396c521f645375107197ea4dfbc7b792quot;>"))

;;; html-mode
(sp-with-modes '(html-mode sgml-mode)
  (sp-local-pair "<" ">"))

;;; lisp modes
(sp-with-modes sp--lisp-modes
  (sp-local-pair "(" nil :bind "C-("))))
#+end_src



